%------------------------------------------------

\begin{fullwidth}

Most academic programs that prepare students for a career in the type of work discussed in this book
spend a disproportionately small amount of time teaching their students coding skills, in relation to the share of
their professional time they will spend writing code their first years after graduating. Recent
Masters' program graduates that have joined our team tended to have very good knowledge in the theory of our
trade, but tended to require a lot of training in its practical skills. To us, it is like hiring architects
that can sketch, describe, and discuss the concepts and requirements of a new building very well, but do
not have the technical skill set to actually contribute to a blueprint using professional standards that can be used
and understood by other professionals during construction. The reasons for this are probably a topic
for another book, but in today's data-driven world, people working in quantitative economics research
must be proficient programmers, and that includes more than being able to compute the correct numbers.

This appendix first has a short section with instructions on how to access and use the code shared in
this book. The second section contains a style guide to Stata. Widely accepted and used style guides
are common in most programming languages, and we think that using such a style guide greatly improves the quality
of research projects coded in Stata. We hope that this guide can  help to increase the emphasis in the Stata community on using,
improving, sharing and standardizing code style. Style guides are the most important tool in how
you, like an architect, draw a blueprint that can be understood and used by everyone in your trade,
and not just by you.

\end{fullwidth}

%------------------------------------------------

\section{How to use the Stata code examples in this book}

You can access the code in the code examples in this book in many ways. We only use Stata's built-in
datasets in our code examples, so you do not need to download any data from anywhere. If you have
Stata installed on your computer, then you will have the data files used in the code.

We use GitHub to version control everything in this book, the code included. To see the code on GitHub, go to
\url{https://github.com/worldbank/d4di/tree/master/code}. If you are familiar with GitHub you can
fork the repository and clone your fork.

A less technical way to access the code is to click the individual file in the URL above, then click
the button that says \textbf{Raw}. You will then get to a page that looks like this
\url{https://raw.githubusercontent.com/worldbank/d4di/master/code/code.do} where you can copy the code
from your browser window to your do-file editor with the formatting intact.
If you want another code file you can modify the URL. This method is only practical for a
single file at the time. If you want to download all code used in this book then you can do that at
\url{https://github.com/worldbank/d4di/archive/master.zip}. That link offers you to download a .zip-file
with all the content used in writing this book, including the \LaTeX{} code used for the book itself. After
extracting the .zip-file you will find all the code in a folder called \texttt{/code/}.

\subsection{Understanding Stata code}

Regardless if you are new to Stata or have used it for decades, you will always run into commands that
you have not seen before or do not remember what they do. Every time that happens you should always look
that command up in the helpfile. For some reason, we often encounter the conception that the helpfiles
are only for beginners. We could not disagree with that conception more, as the only way to get better at Stata
is to constantly read helpfiles. So if there is a command that you do not understand in any of our code
examples, for example \texttt{isid}, then write \verb+help isid+ and the helpfile for the
command \texttt{isid} is opened.

We cannot emphasize too much how important we think it is that you get into the habit of reading helpfiles.

Sometimes you will see user-written commands and you will not be able to read the helpfile until you have
installed them. One example of that in our code if \texttt{reandtreat} or \texttt{ieboilstart}. The
most common place to distribute user-written commands for Stata is Boston College Statistical Software Components
(SSC) archive. In our code examples, we only use either Stata's built-in commands or commands available from the
SSC archive. So, if your installation of Stata does not recognize a command in our code, for example
\texttt{randtreat}, then type \verb+ssc install randtreat+ in Stata.

Some commands on SSC are distributed in packages, for example \texttt{ieboilstart}, meaning that you will
not be able to install it using \verb+ssc install ieboilstart+. If you do, Stata will suggest that you
instead use \verb+findit ieboilstart+ which will search SSC (among other places) and see if there is a
package that has a command called \texttt{ieboilstart}. Stata will find \texttt{ieboilstart} in the package
\texttt{ietoolkit}, so then you will type \verb+ssc install ietoolkit+ instead in Stata.

We understand that this seems confusing the first time you work with this, but this is the best way to set
up your Stata installation to benefit from other people's work that they have made publicly available, and
once used to installing commands like this it will not be confusing at all.

\section{Why we use a style guide}

Programming languages used in computer science always have style guides associated with them. Sometimes
they are official guides that are universally agreed upon, such as PEP8 for
Python\sidenote{https://www.python.org/dev/peps/pep-0008/}. But more commonly, there are well-recognized but
non-official style guides like JavaScript Standard Style\sidenote{https://standardjs.com/\#the-rules} for
JavaScript or Hadley Wickham's\sidenote{http://adv-r.had.co.nz/Style.html} style guide for R.

Aesthetics is an important part of style guides but they are not the main point. The existence of style guides
lifts the quality of the code in that language produced by all programmers in the community.
It is through a style guide that unexperienced programmers learn from more experienced programmers
how certain coding practices are more or less error-prone. Broadly accepted style guides make it easier to
borrow solutions from each other and from examples online without causing bugs that might only be found too
late. Similarly, globally standardized style guides make it easier to solve each others'
problems and to collaborate or move from project to project, and from team to team.

There is room for personal preference in style guides, but style guides are first and foremost
about quality and standardization -- especially when collaborating on code. We believe that a commonly used Stata style guide
would improve the quality of all code written in Stata, which is why we have begun one here. You do not necessarily need to follow our
style guide precisely. We encourage you to write your own style guide if you disagree with us. The best style guide
woud be the one adopted the most widely. What is most important is that you adopt a style guide and follow it consistently across your projects.

\section{The DIME Analytics Stata style guide}

While this section is called \textit{Stata} Style Guide, many of these practices are agnostic to which
programming language you are using, as best practices often relate to concepts that are common across many
languages. If you are coding in a different language, then you might still use many of the guidelines
listed in this section, but you should use your judgment when doing so.

\subsection{Comments}

Comments do nothing to the output of your code, but without them your code will not be accessible to your colleagues.
It will also take you a much longer time to edit code you wrote in the past if you did not comment it well.
So, comment a lot: do not only write \textit{what} your code is doing but also \textit{why} you wrote it like that.

There are three types of comments in Stata and we use them for different purposes.
 We encourage everyone to use them the way we do,
 but the most important thing is that the way you comment your code is consistent.

\codeexample{stata-comments.do}{./code/stata-comments.do}



\subsection{Command Abbreviations}

Stata commands can often be abbreviated in the code. In the help files you can tell if a command can be 
abbreviated if a part of the name is underlined in the syntax section at the top. The abbreviation should not 
be shorter than three characters (even when technically allowed) and abbreviations should only be used when 
widely accepted abbreviation exists. Here are a non-exhaustive list if widely accepted abbreviations of Stata commands.

\begin{center}
	\begin{tabular}{ c | l }
		\hline
		gen & generate \\
		reg & regress \\
		sum & summarize \\
		tab & tabulate \\
		bys & bysort \\
		\hline
	\end{tabular}
\end{center}

A widely accepted two letter abbreviation is \verb|tw| for the command \verb|twoway|.

\subsection{Loops}

It is very common in code examples that the name of the local generated in \verb|foreach| or \verb|forvalues| 
is called something simple as \textit{i} or \textit{j}. This is great for general examples and great when you 
loop over indexes in an array in other programming languages. But since Stata does not have arrays this should 
not be used in Stata code.

Instead, use a local name that describe what you are looping over, for example household members, crops, or 
medicines. This makes your code much more readable, especially as you are starting to nest loops.

\codeexample{stata-loops.do}{./code/stata-loops.do}

\subsection{White Space}

In Stata one space or many spaces does not make a difference to Stata, and this can be used to make the code 
much more readable. In the example below the exact same code is written twice, but in the good example white 
space is used to signal to the reader that the central thing in this segment of code is the variable 
\verb|employed|. Organizing the code like this makes the code much quicker to read, and small typos 
stand out much more making them easier to spot.

We are all very well trained in using white space in software like PowerPoint and Excel as we would never 
present a PowerPoint presentation where the text do not align or submit an Excel table with non-structured 
rows and columns, but for some reason we do it all the time when coding.

\codeexample{stata-whitespace-columns.do}{./code/stata-whitespace-columns.do}

Indentation is another type of white space that makes the code more readable. Any segment of code that is 
repeated in a loop or conditional to an if-statement should have an extra indentation of 4 spaces. If a 
segment is in a loop inside a loop, then it should be indented another 4 spaces, making it 8 spaces more 
indented than the main code. In the do-file editor this indentation can be achieved by using the tab button on 
your keyboard. However, the type of tab used in the do-file editor does not always display the same across 
platforms, for example when publishing the code on GitHub. This is why we use 4 spaces instead of a tab in our 
recommendation. Although the difference is only noticed when the code is displayed outside Stata, so it might 
only be worthwhile to do this in code when formatting it for publication. 

\codeexample{stata-whitespace-indentation.do}{./code/stata-whitespace-indentation.do}

\subsection{Conditional Expressions}

All conditional expressions should be within a parenthesis. And when negating using logical negations,
then \verb|!| should be used and not \verb|~|.

\codeexample{stata-conditional-expressions1.do}{./code/stata-conditional-expressions1.do}

You should also always use \textit{if/else-statements} when applicable even if you can express the same
thing with two separate \textit{if-statements}. When using an \textit{if/else-statements} you are
communicating to anyone reading your code that the two cases are mutually exclusive in an \textit{if/else-statement} 
so that makes your code more readable. It is also less error prone and easier to update.

\codeexample{stata-conditional-expressions2.do}{./code/stata-conditional-expressions2.do}

\subsection{Macros}

Stata has several types of macros where numbers or text can be stored temporarily, but the two most common
macros are \textit{locals} and \textit{globals}. Locals should always be the default and globals should only 
be used when the information stored is used in a different do-file. Globals are error prone since they are 
active as long as Stata is open, which creates a risk that a global from one project is incorrectly used in 
another, so only use globals where they are necessary. Our recommendation is that globals should only be defined in the \textit{Master do-file}.

There are several naming conventions you can use for macros. Which one you use is not as important as you 
and your team is consistent in how you name then. You can use all lower case, \textit{mymacro}, you can use 
underscores \textit{my\_macro} or camel case \textit{myMacro}, or any other style as long as you are consistent.

All globals should be referenced using both the the dollar sign and the curly brackets.

\codeexample{stata-macros.do}{./code/stata-macros.do}

\subsection{File Paths}

All file paths should be absolute and dynamic, should always be enclosed in double quotes and should
always use forwardslashes as Mac and Linux computers cannot read file paths with backslashes. File path 
should also always include the file extension, i.e. \textit{.dta}, \textit{.do}, \textit{.csv}, etc.

\textbf{Absolute file paths} means that the file paths starts at the very root folder of the computer, for 
example \textit{C:\} on a PC or \textit{\User\} on a Mac. This makes sure that
you always get the correct file in the correct folder. We have seen many cases when using \verb|cd| where
a file has been overwritten in another project folder where \verb|cd| was currently pointing to.
Relative file paths are common in many other programming languages, but there they are relative to the
location of the file running the code, and then there is no risk that a file is saved in a completely different folder.

\textbf{Dynamic file paths} use globals that are set in a central master do-file to dynamically build your file
paths. This have the same function as setting \verb|cd| as all new users should only have to change these
file path globals in one location. But dynamic absolute file paths are a better practice since if the
global names are set uniquely there is no risk that files are saved in the incorrect project folder, and
you can create multiple folder globals instead of just one location as with \verb|cd|.

\codeexample{stata-filepaths.do}{./code/stata-filepaths.do}

\subsection{Line Breaks}

Long lines of code are difficult to read if you have to scroll left and right to see the full line of code. 
When your line of code is wider than text on a regular paper you should introduce a line break. This breaks 
the line in the code editor while telling Stata that the same line of code continues on the next row in the 
code editor. There are two line brakes in Stata and one of them is only intended to be used when doing 
advanced programming and is discouraged in an article in Stata's official journal.\cite{cox2005styleguide}

Instead, the three forwardslashes should be used. This is a special case of the two forwardslashed comment 
where the third slash also comments out the new line symbol at the end of that row in the do-file editor.

\codeexample{stata-linebreak.do}{./code/stata-linebreak.do}

\subsection{Boilerplate code}

Boiler plate code is a type of code that always come at the top of the code and its purpose is to harmonize 
the settings across users running the same code to the biggest degree possible. There is no way in Stata to 
guarantee that any two installations of Stata will always run code in exactly the same way. In the vast 
majority of cases it does, but not always, and boilerplate code can mitigate that risk (although not eliminate 
it). We have developed a command that runs many commonly used boilerplate settings that are optimized given 
your installation of Stata. It requires two lines to do the setting that mitigates difference in results due 
to different versions of Stata. 

\codeexample{stata-boilerplate.do}{./code/stata-boilerplate.do}

\subsection{Before Saving}

Similarly to boiler plate code there are good practices that should be followed before saving the data set.	
These are sorting and ordering the data set, dropping intermediate variables that are not needed and 
compressing the data set to save disk space and network bandwidth.

If there is an ID variable or a set of ID variables, then the code should also test that they are uniqueally and 
fully identifying the data set.\sidenote{https://dimewiki.worldbank.org/wiki/ID\_Variable\_Properties} ID 
variables are also perfect variables to sort on, and to order leftmost in the data set.

The command \verb|compress| makes the data set smaller in terms of megabytes without ever loosing any 
information. It optimizes the storage types for all variables and therefore makes it smaller on your computer 
and faster to send over a network or the internet.

\codeexample{stata-before-saving.do}{./code/stata-before-saving.do}


\mainmatter
